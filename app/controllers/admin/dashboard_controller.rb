class Admin::DashboardController < ApplicationController
  include ActivityTrackable
  
  before_action :ensure_admin
  before_action :log_admin_access_activity
  
  def index
    @total_users = User.count
    @admin_users = User.joins(:roles).where(roles: { name: 'admin' }).count
    @recent_users = User.order(created_at: :desc).limit(5)
    @system_stats = {
      total_roles: Role.count,
      recent_logins: @recent_users.count,
      storage_used: "1.2 GB" # Placeholder
    }
  end

  def general_settings
    # Exclude SMTP settings since they have their own dedicated page
    smtp_keys = %w[smtp_enabled smtp_address smtp_port smtp_domain smtp_username smtp_password smtp_authentication mail_from]
    @settings = AppSetting.where.not(key: smtp_keys).order(:key)
    
    # Initialize SSH key settings
    initialize_ssh_key_settings
    
    # Load SSH settings after initialization
    @ssh_settings = AppSetting.where(key: %w[dokku_ssh_private_key dokku_ssh_public_key dokku_ssh_key_path]).order(:key)
    
    # Check if we should use environment variables or database settings
    @using_env_ssh_keys = ENV['DOKKU_SSH_PUBLIC_KEY'].present? || ENV['DOKKU_SSH_KEY_PATH'].present?
  end

  def update_general_settings
    updated_keys = []
    
    # Handle regular settings
    settings_params.each do |key, value|
      setting = AppSetting.find_by(key: key)
      if setting && setting.value != value.to_s
        setting.update!(value: value.to_s)
        updated_keys << key
      end
    end
    
    # Handle SSH key settings
    ssh_params = params.permit(:dokku_ssh_private_key, :dokku_ssh_public_key, :dokku_ssh_key_path)
    ssh_params.each do |key, value|
      setting = AppSetting.find_by(key: key)
      if setting && setting.value != value.to_s
        setting.update!(value: value.to_s)
        updated_keys << key
      end
    end
    
    log_settings_update(current_user, updated_keys) if updated_keys.any?
    
    toast_settings_updated
    redirect_to admin_general_settings_path
  rescue => e
    toast_error("Failed to update settings: #{e.message}", title: "Update Failed")
    redirect_to admin_general_settings_path
  end
  
  def regenerate_ssh_keys
    begin
      # Generate new SSH key pair
      key_pair = generate_ssh_key_pair
      
      # Update settings
      AppSetting.set('dokku_ssh_private_key', key_pair[:private_key])
      AppSetting.set('dokku_ssh_public_key', key_pair[:public_key])
      AppSetting.set('dokku_ssh_key_path', '/app/tmp/ssh_keys/id_ed25519')
      
      log_activity('ssh_keys_regenerated', details: "SSH keys regenerated by admin")
      
      toast_success("SSH keys regenerated successfully!", title: "Keys Regenerated")
    rescue => e
      toast_error("Failed to regenerate SSH keys: #{e.message}", title: "Generation Failed")
    end
    
    redirect_to admin_general_settings_path
  end

  def smtp_settings
    # Define required SMTP environment variables
    required_env_vars = %w[USE_REAL_EMAIL SMTP_ADDRESS SMTP_PORT SMTP_DOMAIN SMTP_USERNAME SMTP_PASSWORD SMTP_AUTHENTICATION MAIL_FROM]
    
    # Check which variables are present and missing
    @present_env_vars = {}
    @missing_env_vars = []
    
    required_env_vars.each do |var|
      if ENV[var].present?
        @present_env_vars[var] = ENV[var]
      else
        @missing_env_vars << var
      end
    end
    
    # Add optional variables that are present
    if ENV['SMTP_ENABLE_STARTTLS_AUTO'].present?
      @present_env_vars['SMTP_ENABLE_STARTTLS_AUTO'] = ENV['SMTP_ENABLE_STARTTLS_AUTO']
    end
    
    @env_fully_configured = @missing_env_vars.empty?
    @using_env_variables = @present_env_vars.any?
    
    # Only load database settings if environment is not fully configured
    unless @env_fully_configured
      @smtp_settings = AppSetting.where(key: %w[smtp_enabled smtp_address smtp_port smtp_domain smtp_username smtp_password smtp_authentication mail_from]).order(:key)
    end
  end

  def update_smtp_settings
    # Check if environment variables are fully configured
    required_env_vars = %w[USE_REAL_EMAIL SMTP_ADDRESS SMTP_PORT SMTP_DOMAIN SMTP_USERNAME SMTP_PASSWORD SMTP_AUTHENTICATION MAIL_FROM]
    env_fully_configured = required_env_vars.all? { |var| ENV[var].present? }
    
    if env_fully_configured
      # Environment variables are fully configured - no database updates needed
      toast_info("SMTP is configured via environment variables. No changes made to database settings.", title: "Environment Configuration Active")
      redirect_to admin_smtp_settings_path
      return
    end
    
    # Environment variables not fully configured, update database settings
    updated_keys = []
    smtp_params.each do |key, value|
      setting = AppSetting.find_by(key: key)
      if setting && setting.value != value.to_s
        setting.update!(value: value.to_s)
        updated_keys << key
      end
    end
    
    if updated_keys.any?
      log_smtp_settings_update(current_user)
      # Update mailer configuration dynamically
      update_mailer_configuration
      toast_smtp_updated
    else
      toast_info("No changes were made to SMTP settings.", title: "No Changes")
    end
    
    redirect_to admin_smtp_settings_path
  rescue => e
    toast_error("Failed to update SMTP settings: #{e.message}", title: "SMTP Update Failed")
    redirect_to admin_smtp_settings_path
  end

  def test_email
    # Ensure mailer configuration is up to date before sending test email
    update_mailer_configuration
    TestMailer.test_email(current_user.email).deliver_now
    toast_test_email_sent
  rescue => e
    toast_error("Failed to send test email: #{e.message}", title: "Email Failed")
  ensure
    redirect_to admin_smtp_settings_path
  end

  def oauth_settings
    log_admin_access_activity
    # Ensure default OAuth settings exist
    OauthSetting.setup_defaults!
    
    @oauth_settings = {
      'google_oauth_enabled' => OauthSetting.find_by(key: 'google_oauth_enabled'),
      'google_client_id' => OauthSetting.find_by(key: 'google_client_id'),
      'google_client_secret' => OauthSetting.find_by(key: 'google_client_secret')
    }
  end

  def update_oauth_settings
    begin
      oauth_params.each do |key, value|
        setting = OauthSetting.find_by(key: key)
        if setting
          if key == 'google_oauth_enabled'
            setting.update!(enabled: value == 'true', value: value)
          else
            setting.update!(value: value)
          end
        end
      end
      
      # Reconfigure OAuth providers with new settings
      reconfigure_oauth_providers
      
      # Log the update
      log_activity('admin_oauth_settings_updated',
                  details: 'Updated OAuth settings configuration')
      
      toast_success("OAuth settings updated successfully! Server restart recommended for changes to take full effect.", title: "Settings Updated")
      redirect_to admin_oauth_settings_path
    rescue => e
      toast_error("Error updating OAuth settings: #{e.message}", title: "Update Failed")
      redirect_to admin_oauth_settings_path
    end
  end

  private

  def reconfigure_oauth_providers
    # Get current OAuth settings
    google_enabled = OauthSetting.google_enabled?
    google_client_id = OauthSetting.google_client_id
    google_client_secret = OauthSetting.google_client_secret
    
    # Also check environment variables which take precedence
    google_client_id = ENV['GOOGLE_CLIENT_ID'].presence || google_client_id
    google_client_secret = ENV['GOOGLE_CLIENT_SECRET'].presence || google_client_secret
    
    # Clear existing Google OAuth provider
    if Devise.omniauth_providers.include?(:google_oauth2)
      # Note: We can't actually remove providers at runtime easily
      # This is a limitation of Devise/OmniAuth
      Rails.logger.info "OAuth settings updated - server restart recommended for changes to take effect"
    end
    
    # Configure Google OAuth if enabled and credentials are available
    if google_enabled && google_client_id.present? && google_client_secret.present?
      begin
        Devise.setup do |config|
          config.omniauth :google_oauth2,
            google_client_id,
            google_client_secret,
            {
              scope: 'userinfo.email,userinfo.profile',
              prompt: 'consent',
              image_aspect_ratio: 'square',
              image_size: 50,
              skip_jwt: true
            }
        end
        Rails.logger.info "Google OAuth reconfigured with client ID: #{google_client_id[0..10]}..."
      rescue => e
        Rails.logger.error "Failed to reconfigure Google OAuth: #{e.message}"
      end
    end
  end

  def ensure_admin
    redirect_to root_path, alert: "Access denied" unless current_user&.admin?
  end

  def settings_params
    params.require(:settings).permit(:app_name, :allow_registration, :require_email_confirmation, :maintenance_mode, :max_file_upload_size, :default_user_role, :dokku_install_version)
  end

  def smtp_params
    params.permit(:smtp_enabled, :smtp_address, :smtp_port, :smtp_domain, :smtp_username, :smtp_password, :smtp_authentication, :mail_from)
  end

  def oauth_params
    params.require(:oauth).permit(:google_oauth_enabled, :google_client_id, :google_client_secret)
  end

  def update_mailer_configuration
    # Check if environment variables are fully configured
    required_env_vars = %w[USE_REAL_EMAIL SMTP_ADDRESS SMTP_PORT SMTP_DOMAIN SMTP_USERNAME SMTP_PASSWORD SMTP_AUTHENTICATION MAIL_FROM]
    env_fully_configured = required_env_vars.all? { |var| ENV[var].present? }
    
    if env_fully_configured
      # Use environment variables exclusively
      smtp_enabled = ENV['USE_REAL_EMAIL']&.downcase == 'true'
      
      if smtp_enabled
        ActionMailer::Base.delivery_method = :smtp
        ActionMailer::Base.smtp_settings = {
          address: ENV['SMTP_ADDRESS'],
          port: ENV['SMTP_PORT'].to_i,
          domain: ENV['SMTP_DOMAIN'],
          user_name: ENV['SMTP_USERNAME'],
          password: ENV['SMTP_PASSWORD'],
          authentication: ENV['SMTP_AUTHENTICATION'].to_sym,
          enable_starttls_auto: (ENV['SMTP_ENABLE_STARTTLS_AUTO']&.downcase == 'true') || true
        }
        ActionMailer::Base.default_options = { from: ENV['MAIL_FROM'] }
      else
        ActionMailer::Base.delivery_method = :letter_opener if Rails.env.development?
      end
    else
      # Use database settings
      smtp_enabled = AppSetting.get('smtp_enabled', false)
      
      if smtp_enabled
        ActionMailer::Base.delivery_method = :smtp
        ActionMailer::Base.smtp_settings = {
          address: AppSetting.get('smtp_address'),
          port: AppSetting.get('smtp_port', 587).to_i,
          domain: AppSetting.get('smtp_domain'),
          user_name: AppSetting.get('smtp_username'),
          password: AppSetting.get('smtp_password'),
          authentication: AppSetting.get('smtp_authentication', 'plain').to_sym,
          enable_starttls_auto: true
        }
        ActionMailer::Base.default_options = { from: AppSetting.get('mail_from', 'no-reply@example.com') }
      else
        ActionMailer::Base.delivery_method = :letter_opener if Rails.env.development?
      end
    end
  end

  def log_admin_access_activity
    area = case action_name
    when 'index'
      'dashboard'
    when 'general_settings'
      'general settings'
    when 'smtp_settings'
      'SMTP settings'
    when 'oauth_settings'
      'OAuth settings'
    else
      action_name.humanize
    end
    
    log_admin_access(current_user, area)
  end
  
  def initialize_ssh_key_settings
    # Check if SSH keys are configured via environment variables
    if ENV['DOKKU_SSH_PUBLIC_KEY'].present? && ENV['DOKKU_SSH_KEY_PATH'].present?
      # Use environment variable values if they exist
      AppSetting.find_or_create_by!(key: 'dokku_ssh_public_key') do |setting|
        setting.value = ENV['DOKKU_SSH_PUBLIC_KEY']
        setting.setting_type = 'string'
        setting.description = 'SSH public key for connecting to Dokku servers'
      end
      
      AppSetting.find_or_create_by!(key: 'dokku_ssh_key_path') do |setting|
        setting.value = ENV['DOKKU_SSH_KEY_PATH']
        setting.setting_type = 'string'
        setting.description = 'Path to SSH private key file'
      end
      
      # Try to read private key from file if path is provided
      if File.exist?(File.expand_path(ENV['DOKKU_SSH_KEY_PATH']))
        private_key_content = File.read(File.expand_path(ENV['DOKKU_SSH_KEY_PATH']))
        AppSetting.find_or_create_by!(key: 'dokku_ssh_private_key') do |setting|
          setting.value = private_key_content
          setting.setting_type = 'string'
          setting.description = 'SSH private key for connecting to Dokku servers'
        end
      end
    else
      # Generate SSH keys if they don't exist in database
      unless AppSetting.exists?(key: 'dokku_ssh_public_key') && AppSetting.exists?(key: 'dokku_ssh_private_key')
        key_pair = generate_ssh_key_pair
        
        AppSetting.find_or_create_by!(key: 'dokku_ssh_private_key') do |setting|
          setting.value = key_pair[:private_key]
          setting.setting_type = 'string'
          setting.description = 'SSH private key for connecting to Dokku servers'
        end
        
        AppSetting.find_or_create_by!(key: 'dokku_ssh_public_key') do |setting|
          setting.value = key_pair[:public_key]
          setting.setting_type = 'string'
          setting.description = 'SSH public key for connecting to Dokku servers'
        end
        
        AppSetting.find_or_create_by!(key: 'dokku_ssh_key_path') do |setting|
          setting.value = '/app/tmp/ssh_keys/id_ed25519'
          setting.setting_type = 'string'
          setting.description = 'Path to SSH private key file'
        end
      end
    end
  end
  
  def generate_ssh_key_pair
    require 'tempfile'
    require 'fileutils'
    
    Tempfile.create(['ssh_key', '']) do |temp_file|
      temp_path = temp_file.path
      
      # Generate key using ssh-keygen
      result = system("ssh-keygen -t ed25519 -f #{temp_path} -N '' -q")
      
      unless result
        raise "Failed to generate SSH keys using ssh-keygen"
      end
      
      if File.exist?(temp_path) && File.exist?("#{temp_path}.pub")
        private_key = File.read(temp_path)
        public_key = File.read("#{temp_path}.pub").strip
        
        # Clean up
        File.delete(temp_path) if File.exist?(temp_path)
        File.delete("#{temp_path}.pub") if File.exist?("#{temp_path}.pub")
        
        {
          private_key: private_key,
          public_key: public_key,
          fingerprint: Digest::SHA256.hexdigest(public_key)
        }
      else
        raise "SSH key files were not created successfully"
      end
    end
  end
end
